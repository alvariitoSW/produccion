================================================================================
                    INFORME DE AUDITOR√çA: strategy_engine.py
                    Bot de Trading Polymarket - Mean Reversion Ladder
                    Fecha: 4 de Febrero de 2026
================================================================================

√çNDICE
------
1. Resumen Ejecutivo
2. Arquitectura General
3. An√°lisis Funci√≥n por Funci√≥n
4. Casos L√≠mite y Soluciones Implementadas
5. Flujo de Datos Cr√≠ticos
6. Conclusiones

================================================================================
1. RESUMEN EJECUTIVO
================================================================================

El archivo strategy_engine.py implementa el n√∫cleo de la estrategia de trading
"Mean Reversion Ladder" para mercados de predicci√≥n en Polymarket.

ESTAD√çSTICAS:
- Total de l√≠neas: 1,065
- Funciones p√∫blicas: 8
- Funciones privadas: 7
- Estructuras de datos: 9 diccionarios de estado

PROBLEMAS CR√çTICOS RESUELTOS EN ESTA VERSI√ìN:
‚úÖ Bug cr√≠tico: Bot vend√≠a TODO el balance en lugar del acumulado
‚úÖ Tokens bloqueados: C√°lculo de locked_in_sells para √≥rdenes abiertas
‚úÖ M√≠nimo din√°mico: $1 USDC nocional en lugar de 5 shares fijas
‚úÖ Precisi√≥n float: Truncado a 6 decimales para evitar errores de balance
‚úÖ Race conditions: Auditor√≠a de √≥rdenes canceladas que pueden haber llenado
‚úÖ Partial fills: Procesamiento incremental con delta (no acumulativo)

================================================================================
2. ARQUITECTURA GENERAL
================================================================================

CLASE: StrategyEngine
---------------------
Responsabilidad: Gestionar la estrategia completa de trading para eventos
de Polymarket, incluyendo:
- Colocaci√≥n de escalera de √≥rdenes de compra (ladder)
- Detecci√≥n y procesamiento de fills
- Colocaci√≥n autom√°tica de √≥rdenes de venta (take-profit)
- Gesti√≥n de stop-loss client-side
- Recarga de posiciones en PRE_MARKET
- Transici√≥n a modo LIVE

ESTADOS DEL CICLO DE VIDA:
1. ACCUMULATING: Fase PRE_MARKET, comprando a precios bajos
2. EXITING: Evento LIVE, solo vendiendo posiciones
3. COMPLETED: Todas las ventas ejecutadas

ESTRUCTURAS DE DATOS PRINCIPALES:
---------------------------------
_states: Dict[str, StrategyState]
    ‚Üí Estado actual de cada evento (ACCUMULATING/EXITING/COMPLETED)

_positions: Dict[str, List[Position]]
    ‚Üí Posiciones abiertas por evento

_buy_orders: Dict[str, List[TrackedOrder]]
    ‚Üí √ìrdenes de compra colocadas por evento

_sell_orders: Dict[str, List[TrackedOrder]]
    ‚Üí √ìrdenes de venta (take-profit) por evento

_stop_loss_orders: Dict[str, List[TrackedOrder]]
    ‚Üí √ìrdenes de stop-loss por evento

_known_filled: Set[str]
    ‚Üí IDs de √≥rdenes ya procesadas (evita duplicados)

_pending_sells: List[Dict]
    ‚Üí Cola de ventas fallidas para reintentar

_fill_accumulator: Dict[tuple, Dict]
    ‚Üí Acumulador de fills parciales por (slug, side, token_id, exit_price)
    ‚Üí CR√çTICO: Clave incluye exit_price para separar entradas 47¬¢‚Üí48¬¢ de 48¬¢‚Üí49¬¢

================================================================================
3. AN√ÅLISIS FUNCI√ìN POR FUNCI√ìN
================================================================================

-------------------------------------------------------------------------------
3.1. __init__(self, client: PolymarketClient)
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 31-50

PROP√ìSITO:
Constructor de la clase. Inicializa todas las estructuras de datos necesarias
para el seguimiento del estado de la estrategia.

L√ìGICA:
1. Guarda referencia al cliente de Polymarket
2. Obtiene instancia del notificador de Telegram
3. Inicializa 9 diccionarios/sets vac√≠os para tracking de estado

POR QU√â EST√Å AH√ç:
Es el punto de entrada para crear una instancia del motor de estrategia.
Centraliza toda la inicializaci√≥n en un solo lugar.

QU√â RESUELVE:
- Evita errores de KeyError al acceder a diccionarios no inicializados
- Garantiza estado limpio al crear nueva instancia

-------------------------------------------------------------------------------
3.2. _get_exit_price(self, entry_price: float) -> float
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 52-62

PROP√ìSITO:
Determina el precio de salida (take-profit) basado en el precio de entrada.

L√ìGICA:
1. Redondea el precio de entrada a 2 decimales (evita errores de precisi√≥n float)
2. Busca en diccionario EXIT_PRICES el precio de salida correspondiente
3. Retorna 49¬¢ por defecto si no encuentra mapeo

MAPEO DE PRECIOS (desde config.py):
- Entrada 48¬¢ ‚Üí Salida 49¬¢ (spread 1¬¢ = 2.08% profit)
- Entrada 46-47¬¢ ‚Üí Salida 48¬¢ (spread 1-2¬¢)
- Entrada 40-45¬¢ ‚Üí Salida 47¬¢ (spread 2-7¬¢)

POR QU√â EST√Å AH√ç:
La estrategia de mean reversion requiere spreads din√°micos. Entradas m√°s
arriesgadas (precios bajos) deben tener mayor spread de protecci√≥n.

QU√â RESUELVE:
- Centraliza la l√≥gica de mapeo entry‚Üíexit
- El redondeo a 2 decimales evita bugs como 0.4799999999 != 0.48

-------------------------------------------------------------------------------
3.3. _needs_stop_loss(self, entry_price: float) -> bool
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 64-67

PROP√ìSITO:
Determina si una entrada necesita stop-loss basado en su precio.

L√ìGICA:
1. Redondea precio a 2 decimales
2. Verifica si est√° en el set STOP_LOSS_ENTRIES (t√≠picamente solo 48¬¢)

POR QU√â EST√Å AH√ç:
Las entradas a 48¬¢ son las m√°s arriesgadas (cerca del 50%). Si el mercado
se mueve en contra, la p√©rdida potencial es mayor. Solo estas necesitan
protecci√≥n adicional con stop-loss.

QU√â RESUELVE:
- Evita colocar stop-loss innecesarios en entradas seguras (40-47¬¢)
- Reduce complejidad de la l√≥gica OCO (One-Cancels-Other)

-------------------------------------------------------------------------------
3.4. initialize_event(self, event: EventContext) -> int
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 69-186

PROP√ìSITO:
Inicializa la estrategia para un nuevo evento. Coloca la escalera de √≥rdenes
de compra o recupera √≥rdenes existentes si el bot se reinici√≥.

L√ìGICA DETALLADA:

FASE 1 - VALIDACI√ìN (l√≠neas 78-90):
    if slug in self._states:
        return 0  # Ya inicializado
    
    if event.phase != MarketPhase.PRE_MARKET:
        logger.error("REJECTED: Solo PRE_MARKET permitido")
        return 0

FASE 2 - INICIALIZACI√ìN DE ESTADO (l√≠neas 92-98):
    self._states[slug] = StrategyState.ACCUMULATING
    self._positions[slug] = []
    self._results[slug] = CycleResult(...)
    self._buy_orders[slug] = []
    self._sell_orders[slug] = []
    self._stop_loss_orders[slug] = []

FASE 3 - RECUPERACI√ìN DE ESTADO (l√≠neas 100-162):
    existing_orders = self.client.get_open_orders()
    relevant_orders = [filtrar por token_id del evento]
    
    if relevant_orders:
        # Reconstruir TrackedOrder desde datos de API
        # Agregar a _buy_orders o _sell_orders seg√∫n tipo
        return recovered_count  # NO colocar nuevas √≥rdenes

FASE 4 - COLOCACI√ìN DE LADDER (l√≠neas 164-186):
    for side in [YES, NO]:
        for price in LADDER_LEVELS:  # [0.40, 0.42, ..., 0.48]
            order = client.place_limit_order(...)
            _buy_orders[slug].append(order)

POR QU√â EST√Å AH√ç:
Es el punto de entrada para comenzar a operar un nuevo evento. Debe:
1. Prevenir inicializaci√≥n doble
2. Rechazar eventos que ya est√°n LIVE
3. Recuperar estado si el bot se reinici√≥ mid-evento

QU√â RESUELVE:
- CASO L√çMITE: Reinicio del bot ‚Üí No coloca √≥rdenes duplicadas
- CASO L√çMITE: Evento ya LIVE ‚Üí Rechazado para evitar p√©rdidas
- Idempotencia: Llamar m√∫ltiples veces es seguro

-------------------------------------------------------------------------------
3.5. check_fills(self, event: EventContext, open_order_ids: Optional[Set[str]]) 
     -> Optional[Set[str]]
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 188-316

PROP√ìSITO:
Detecta y procesa √≥rdenes que han sido llenadas (parcial o totalmente).
Es el "coraz√≥n" del sistema de detecci√≥n de fills.

L√ìGICA DETALLADA:

SECCI√ìN 1 - VERIFICACI√ìN DE COMPRAS (l√≠neas 215-270):

    # Optimizaci√≥n: Ordenar por precio DESC (48¬¢ primero)
    active_buys_sorted = sorted(active_buys, key=lambda o: o.price, reverse=True)
    
    for order in active_buys_sorted:
        # OPTIMIZACI√ìN: Solo consultar API si:
        # 1. Orden desapareci√≥ de open_order_ids (probable fill)
        # 2. Orden es "alta prioridad" (‚â•46¬¢) - revisar siempre
        
        if not (order_missing or is_high_priority):
            continue  # Skip √≥rdenes de baja prioridad que siguen abiertas
        
        order_data = client.get_order(order.order_id)
        size_matched = float(order_data.get("size_matched", 0))
        
        # CR√çTICO: Procesar solo el DELTA (nuevo desde √∫ltima revisi√≥n)
        delta_fill = size_matched - order.processed_size
        
        if delta_fill > 0.000001:
            safe_delta = round(delta_fill, 6)
            self._process_buy_fill(order, event, fill_amount=safe_delta)
            order.processed_size = size_matched  # Actualizar para siguiente ciclo

SECCI√ìN 2 - VERIFICACI√ìN DE VENTAS (l√≠neas 272-304):

    for order in _sell_orders[slug]:
        if order.order_id not in open_order_ids:
            # Orden desapareci√≥ ‚Üí probable fill
            order_data = client.get_order(order.order_id)
            
            # SAFETY: Validar que API retorn√≥ datos
            if order_data is None:
                continue  # Reintentar en siguiente ciclo
            
            if size_matched > 0:
                self._process_sell_fill(order, event)
            
            # PARTIAL FILL: Solo marcar como _known_filled si est√° 100% lleno
            if size_matched >= original_size:
                _known_filled.add(order.order_id)

SECCI√ìN 3 - MONITOR DE STOP-LOSS (l√≠neas 306-312):

    self._check_stop_loss(event, open_order_ids)

SECCI√ìN 4 - RETORNO DE IDs CACHEADOS (l√≠nea 316):

    return open_order_ids  # Reusar en check_completion()

POR QU√â EST√Å AH√ç:
Sin detecci√≥n de fills, el bot no sabr√≠a cu√°ndo colocar √≥rdenes de venta.
Es el sistema de "sensores" que detecta actividad en el mercado.

QU√â RESUELVE:
- CASO L√çMITE: Partial fills ‚Üí Usa delta, no acumulativo
- CASO L√çMITE: API retorna None ‚Üí Skip seguro, reintenta despu√©s
- CASO L√çMITE: Orden de alta prioridad (48¬¢) ‚Üí Revisar cada ciclo
- OPTIMIZACI√ìN: No consultar API para √≥rdenes de baja prioridad que siguen abiertas

-------------------------------------------------------------------------------
3.6. process_pending_sells(self) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 318-481

PROP√ìSITO:
Reintenta colocar √≥rdenes de venta que fallaron anteriormente.
Llamada UNA VEZ por ciclo desde main.py (no por evento).

L√ìGICA DETALLADA:

FASE 1 - VALIDACI√ìN DE DUST (l√≠neas 330-345):

    notional_value = pending['size'] * pending['exit_price']
    
    if notional_value < MIN_NOTIONAL_VALUE_USDC:  # $1 m√≠nimo
        logger.error("DUST REJECTED: No cumple m√≠nimo nocional")
        continue  # No reintentar, siempre fallar√°

FASE 2 - INTENTO DE COLOCACI√ìN (l√≠neas 347-373):

    sell_order = client.place_limit_order(...)
    
    if sell_order:
        _sell_orders[slug].append(sell_order)
        notifier.send_sell_placed(...)
    else:
        # Fall√≥ ‚Üí investigar por qu√©

FASE 3 - DIAGN√ìSTICO INTELIGENTE DE FALLO (l√≠neas 375-481):

    actual_balance = client.get_token_balance(token_id)
    
    # ‚ö†Ô∏è CR√çTICO: Calcular tokens bloqueados en ventas abiertas
    open_orders = client.get_open_orders()
    locked_in_sells = sum(
        size - size_matched
        for o in open_orders
        if o.asset_id == token_id and o.side == "SELL"
    )
    
    available_balance = actual_balance - locked_in_sells
    
    ESCENARIOS:
    
    A) available_balance <= 0:
        ‚Üí Tokens bloqueados en otras ventas
        ‚Üí Verificar si ya existe orden duplicada
        ‚Üí Si existe: remover de pending
        ‚Üí Si no: reintentar brevemente (5 intentos max)
    
    B) actual_balance == 0:
        ‚Üí Delay de settlement (tokens no en blockchain a√∫n)
        ‚Üí Reintentar hasta 60 intentos (~30 segundos)
        ‚Üí Despu√©s: alertar por Telegram
    
    C) 0 < available_balance < pending['size']:
        ‚Üí Balance parcial disponible
        ‚Üí Ajustar size al disponible (truncar a 6 decimales)
        ‚Üí Validar que ajustado cumple m√≠nimo nocional
    
    D) available_balance >= pending['size']:
        ‚Üí Tenemos suficiente pero API fall√≥
        ‚Üí Reintentar hasta 10 intentos
        ‚Üí Despu√©s: alertar cr√≠tica por Telegram

POR QU√â EST√Å AH√ç:
Las √≥rdenes de venta pueden fallar por m√∫ltiples razones:
- Settlement delay: tokens no disponibles inmediatamente
- Balance insuficiente: ya vendido por otra orden
- Error de API: timeout, rate limit, etc.

QU√â RESUELVE:
- CASO L√çMITE: Settlement delay ‚Üí Reintento con timeout de 30s
- CASO L√çMITE: Tokens bloqueados ‚Üí Detecta y evita duplicados
- CASO L√çMITE: Balance parcial ‚Üí Ajusta tama√±o autom√°ticamente
- CASO L√çMITE: Dust ‚Üí Rechaza si no cumple $1 m√≠nimo

-------------------------------------------------------------------------------
3.7. _check_stop_loss(self, event: EventContext, open_order_ids: set) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 483-551

PROP√ìSITO:
Monitor client-side de stop-loss para entradas de alto riesgo (48¬¢).
Si el precio cae a STOP_LOSS_PRICE (ej: 18¬¢), ejecuta venta a mercado.

L√ìGICA DETALLADA:

    for order in _sell_orders[slug]:
        # Skip si ya procesado o ya llenado
        if order.order_id in _known_filled or order.order_id not in open_order_ids:
            continue
        
        # Solo aplicar a entradas que necesitan stop-loss (48¬¢)
        if not _needs_stop_loss(order.entry_price):
            continue
        
        # Obtener precio actual del mercado (best bid)
        current_market_price = event.yes_bid o event.no_bid
        
        # TRIGGER: Si precio cae al umbral
        if current_market_price <= STOP_LOSS_PRICE:
            
            # 1. Cancelar orden de take-profit (liberar tokens)
            client.cancel_order(order.order_id)
            _known_filled.add(order.order_id)
            
            # 2. Vender a mercado (limit a 1¬¢ cruza cualquier bid)
            dump_order = client.place_limit_order(
                price=0.01,  # "Market sell"
                size=order.size,
                ...
            )
            
            # 3. Notificar
            if dump_order:
                notifier.send_message("STOP-LOSS EJECUTADO")
            else:
                notifier.send_message("ALERTA: Stop-loss fall√≥")

POR QU√â EST√Å AH√ç:
Polymarket no tiene √≥rdenes stop-loss nativas. Debemos implementar
monitoreo client-side para proteger posiciones de alto riesgo.

QU√â RESUELVE:
- CASO L√çMITE: Mercado colapsa ‚Üí Vende antes de p√©rdida total
- CASO L√çMITE: Solo 48¬¢ ‚Üí No afecta entradas m√°s seguras
- CASO L√çMITE: Tokens bloqueados ‚Üí Cancela TP antes de vender

-------------------------------------------------------------------------------
3.8. _flush_accumulator_for_event(self, event: EventContext) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 553-656

PROP√ìSITO:
Vac√≠a el acumulador de fills parciales cuando el evento pasa a LIVE.
Intenta vender lo acumulado si cumple m√≠nimo, o marca como "dust" si no.

L√ìGICA DETALLADA:

    # Encontrar todas las claves del acumulador para este evento
    keys_to_flush = [k for k in _fill_accumulator.keys() if k[0] == slug]
    
    for acc_key in keys_to_flush:
        acc = _fill_accumulator[acc_key]
        
        if acc['size'] > 0.001:  # Tama√±o significativo
            _, side, token_id, exit_price = acc_key
            sell_size = acc['size']  # ‚ö†Ô∏è CR√çTICO: Usar tama√±o del acumulador
            
            # Calcular valor nocional
            notional_value = sell_size * exit_price
            
            if notional_value < MIN_NOTIONAL_VALUE_USDC:
                # DUST: No se puede vender
                logger.error("DUST LOCKED: Expirar√° sin valor")
                notifier.send_message("DUST LOCKED...")
                _fill_accumulator[acc_key] = {'size': 0.0, ...}
                continue
            
            # üõ°Ô∏è SAFETY: Verificar balance disponible
            actual_balance = client.get_token_balance(token_id)
            
            # Calcular tokens bloqueados en ventas abiertas
            locked_in_sells = sum(...)
            available_balance = actual_balance - locked_in_sells
            
            # ‚ö†Ô∏è CR√çTICO: Solo REDUCIR si necesario, no REEMPLAZAR
            if available_balance < sell_size:
                if available_balance <= 0:
                    continue  # Todo bloqueado
                sell_size = truncate_6_decimals(available_balance)
            
            # Agregar a cola de pending sells
            _pending_sells.append({
                'token_id': token_id,
                'size': sell_size,  # Tama√±o del acumulador (posiblemente reducido)
                ...
            })
            
            # Limpiar acumulador
            _fill_accumulator[acc_key] = {'size': 0.0, 'total_entry_value': 0.0}

POR QU√â EST√Å AH√ç:
Durante PRE_MARKET, pueden llegar partial fills que no cumplen el m√≠nimo
de $1 USDC individualmente. El acumulador los junta hasta que cumplen.
Cuando el evento pasa a LIVE, debemos procesar lo que qued√≥ acumulado.

QU√â RESUELVE:
- CASO L√çMITE: Partial fills peque√±os ‚Üí Acumula hasta cumplir m√≠nimo
- CASO L√çMITE: Dust al pasar a LIVE ‚Üí Notifica que se perder√°
- CASO L√çMITE: Tokens bloqueados ‚Üí Reduce tama√±o o skip
- BUG CR√çTICO RESUELTO: Usaba balance total, ahora usa acc['size']

-------------------------------------------------------------------------------
3.9. _process_buy_fill(self, order: TrackedOrder, event: EventContext, 
                        fill_amount: Optional[float] = None) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 658-821

PROP√ìSITO:
Procesa un fill de compra. Acumula shares y coloca orden de venta cuando
se alcanza el m√≠nimo de $1 USDC nocional.

L√ìGICA DETALLADA:

FASE 1 - PREPARACI√ìN (l√≠neas 664-680):

    entry_price = order.price
    exit_price = _get_exit_price(entry_price)
    actual_size = fill_amount or order.size
    
    # Notificar por Telegram
    notifier.send_message("BUY FILLED...")
    
    # Registrar posici√≥n
    _positions[slug].append(Position(...))
    _results[slug].fills_yes/no.append(entry_price)

FASE 2 - ACUMULACI√ìN (l√≠neas 700-725):

    # Calcular m√≠nimo de shares para cumplir $1 USDC
    min_shares_required = (MIN_NOTIONAL_VALUE_USDC / exit_price) * 1.01
    
    # Clave del acumulador incluye exit_price
    # ‚Üí Separa entradas 47¬¢‚Üí48¬¢ de 48¬¢‚Üí49¬¢
    acc_key = (slug, order.side, order.token_id, exit_price)
    
    # Acumular
    acc['size'] += actual_size
    acc['total_entry_value'] += actual_size * entry_price
    
    logger.info(f"Accumulated: {acc['size']} shares (need {min_shares_required})")

FASE 3 - DECISI√ìN DE VENTA (l√≠neas 727-821):

    SELL_THRESHOLD = min_shares_required * 0.99  # 99% para partial fills
    
    if acc['size'] >= SELL_THRESHOLD:
        avg_entry = acc['total_entry_value'] / acc['size']
        
        # ‚ö†Ô∏è CR√çTICO: sell_size = acc['size'], NO total balance
        sell_size = acc['size']
        
        # üõ°Ô∏è SAFETY: Verificar balance disponible
        actual_balance = client.get_token_balance(token_id)
        
        # Calcular locked_in_sells
        locked_in_sells = sum(
            size - size_matched
            for o in open_orders
            if o.asset_id == token_id and o.side == "SELL"
        )
        
        available_balance = actual_balance - locked_in_sells
        
        # ‚ö†Ô∏è CR√çTICO: Solo REDUCIR si necessary
        if available_balance < sell_size:
            if available_balance <= 0:
                return  # No limpiar acumulador, reintentar despu√©s
            sell_size = truncate_6_decimals(available_balance)
        
        # Validar m√≠nimo nocional
        if sell_size * exit_price < MIN_NOTIONAL_VALUE_USDC:
            logger.error("DUST")
            _fill_accumulator[acc_key] = {'size': 0.0, ...}
            return
        
        # Limpiar acumulador
        _fill_accumulator[acc_key] = {'size': 0.0, 'total_entry_value': 0.0}
        
        # Colocar orden de venta
        sell_order = client.place_limit_order(
            price=exit_price,
            size=sell_size,  # Del acumulador, no del balance total
            ...
        )
        
        if sell_order:
            _sell_orders[slug].append(sell_order)
            notifier.send_sell_placed(...)
        else:
            _pending_sells.append(...)  # Reintentar despu√©s

POR QU√â EST√Å AH√ç:
Es el core de la estrategia: cuando compramos, debemos vender a profit.
Sin esta funci√≥n, el bot comprar√≠a pero nunca vender√≠a.

QU√â RESUELVE:
- CASO L√çMITE: Partial fills < $1 ‚Üí Acumula hasta cumplir
- CASO L√çMITE: Tokens bloqueados ‚Üí Reduce tama√±o o espera
- BUG CR√çTICO RESUELTO: Antes usaba available_balance como sell_size
  (vend√≠a TODO el balance), ahora usa acc['size'] (solo lo acumulado)
- CASO L√çMITE: API falla ‚Üí Cola de pending_sells para retry

-------------------------------------------------------------------------------
3.10. audit_cancelled_orders(self, order_ids: List[str], event: EventContext)
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 823-884

PROP√ìSITO:
Audita √≥rdenes de compra que fueron canceladas para detectar fills ocultos
que ocurrieron durante la "race condition" de cancelaci√≥n.

L√ìGICA DETALLADA:

    logger.info(f"Auditing {len(order_ids)} cancelled orders...")
    
    # Encontrar TrackedOrders correspondientes
    orders_to_audit = [
        o for o in _buy_orders[slug]
        if o.order_id in order_ids
    ]
    
    for order in orders_to_audit:
        order_data = client.get_order(order.order_id)
        
        # SAFETY: Validar que API retorn√≥ datos
        if not order_data:
            continue
        
        size_matched = float(order_data.get("size_matched", 0))
        
        if size_matched > 0:
            # DELTA logic: Solo procesar fills nuevos
            delta_fill = size_matched - order.processed_size
            
            if delta_fill > 0.000001:
                logger.warning(f"RACE CONDITION: Found {delta_fill} hidden shares!")
                
                safe_delta = round(delta_fill, 6)
                self._process_buy_fill(order, event, fill_amount=safe_delta)
                order.processed_size = size_matched
            
            if size_matched >= original_size:
                _known_filled.add(order.order_id)

POR QU√â EST√Å AH√ç:
Cuando el evento pasa a LIVE, cancelamos todas las √≥rdenes de compra en batch.
Pero entre que enviamos la cancelaci√≥n y se ejecuta, alguna orden puede haber
sido llenada. Sin esta auditor√≠a, perder√≠amos esos fills.

QU√â RESUELVE:
- CASO L√çMITE: Race condition en cancelaci√≥n ‚Üí Detecta fills ocultos
- CASO L√çMITE: API retorna None ‚Üí Skip seguro
- CASO L√çMITE: Fill ya procesado parcialmente ‚Üí Usa delta, no acumulativo

-------------------------------------------------------------------------------
3.11. _process_sell_fill(self, order: TrackedOrder, event: EventContext,
                          is_stop_loss: bool = False) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 886-964

PROP√ìSITO:
Procesa un fill de venta (take-profit o stop-loss). Calcula PnL, ejecuta
l√≥gica OCO, y opcionalmente recarga la posici√≥n si est√° en PRE_MARKET.

L√ìGICA DETALLADA:

FASE 1 - C√ÅLCULO DE PnL (l√≠neas 895-912):

    entry_price = order.entry_price or 0
    pnl = (order.price - entry_price) * order.size
    _results[slug].total_pnl += pnl
    
    if is_stop_loss:
        logger.warning("STOP-LOSS HIT: Loss $X")
    else:
        logger.info("TAKE-PROFIT: PnL $X")

FASE 2 - L√ìGICA OCO (l√≠neas 914-938):

    # Solo para entradas que tienen stop-loss (48¬¢)
    if _needs_stop_loss(entry_price):
        
        if is_stop_loss:
            # Stop-loss ejecutado ‚Üí Cancelar take-profit
            for sell in _sell_orders[slug]:
                if sell.entry_price ‚âà entry_price:
                    client.cancel_order(sell.order_id)
                    _known_filled.add(sell.order_id)
                    break
        else:
            # Take-profit ejecutado ‚Üí Cancelar stop-loss
            for stop in _stop_loss_orders[slug]:
                if stop.entry_price ‚âà entry_price:
                    client.cancel_order(stop.order_id)
                    _known_filled.add(stop.order_id)
                    break

FASE 3 - LIMPIEZA DE POSICI√ìN (l√≠neas 940-948):

    for pos in _positions[slug]:
        if pos.side == order.side and pos.entry_price ‚âà entry_price:
            _positions[slug].remove(pos)
            break
    
    notifier.send_fill(order, pnl=pnl)

FASE 4 - RELOAD EN PRE_MARKET (l√≠neas 950-964):

    # Solo si estamos en ACCUMULATING (PRE_MARKET) y NO es stop-loss
    if _states[slug] == StrategyState.ACCUMULATING and not is_stop_loss:
        reload_order = client.place_limit_order(
            price=entry_price,  # Mismo precio que antes
            size=order.size,
            type=BUY
        )
        
        if reload_order:
            _buy_orders[slug].append(reload_order)
            logger.info("RELOAD: Replenished buy")

POR QU√â EST√Å AH√ç:
Completa el ciclo de trading. Cuando vendemos, necesitamos:
1. Calcular si ganamos o perdimos dinero
2. Cancelar √≥rdenes relacionadas (OCO)
3. Limpiar estado interno
4. Recargar si hay oportunidad (PRE_MARKET)

QU√â RESUELVE:
- CASO L√çMITE: OCO ‚Üí Evita que queden √≥rdenes hu√©rfanas
- CASO L√çMITE: Stop-loss no recarga ‚Üí Evita perseguir p√©rdidas
- CASO L√çMITE: PRE_MARKET ‚Üí Aprovecha oportunidades de reload

-------------------------------------------------------------------------------
3.12. transition_to_live(self, event: EventContext) -> int
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 966-1006

PROP√ìSITO:
Maneja la transici√≥n del evento de PRE_MARKET a LIVE.
Cancela todas las √≥rdenes de compra y prepara para modo solo-salida.

L√ìGICA DETALLADA:

    if _states[slug] != StrategyState.ACCUMULATING:
        return 0  # Ya transicionado o no inicializado
    
    # Recolectar IDs de √≥rdenes a cancelar
    order_ids_to_cancel = [
        o.order_id for o in _buy_orders[slug]
        if o.order_id not in _known_filled
    ]
    
    # Cancelaci√≥n en batch (una llamada API)
    cancelled = client.cancel_orders_batch(order_ids_to_cancel)
    
    # üõ°Ô∏è AUDITOR√çA DE RACE CONDITION
    if order_ids_to_cancel:
        self.audit_cancelled_orders(order_ids_to_cancel, event)
    
    # üì¶ FLUSH ACCUMULATOR
    self._flush_accumulator_for_event(event)
    
    # Cambiar estado
    _states[slug] = StrategyState.EXITING
    
    notifier.send_phase_transition(event, cancelled)
    return cancelled

POR QU√â EST√Å AH√ç:
Cuando el evento pasa a LIVE, las probabilidades ya no son favorables
para comprar. Debemos:
1. Cancelar compras pendientes (ya no queremos m√°s posiciones)
2. Detectar fills de √∫ltima hora (race condition)
3. Procesar cualquier acumulaci√≥n pendiente
4. Cambiar a modo "solo venta"

QU√â RESUELVE:
- CASO L√çMITE: Race condition ‚Üí Audita √≥rdenes canceladas
- CASO L√çMITE: Fills acumulados ‚Üí Flush antes de cambiar modo
- OPTIMIZACI√ìN: Batch cancel ‚Üí Una llamada API en lugar de N

-------------------------------------------------------------------------------
3.13. check_completion(self, event: EventContext, cached_open_ids: set) -> bool
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 1008-1045

PROP√ìSITO:
Verifica si la estrategia est√° completa para un evento.
Completo = modo EXITING + sin √≥rdenes de venta abiertas.

L√ìGICA:

    if _states[slug] != StrategyState.EXITING:
        return False  # A√∫n no en modo salida
    
    # Usar IDs cacheados si disponibles (optimizaci√≥n)
    open_ids = cached_open_ids or {fetch from API}
    
    has_pending_sells = any(
        o.order_id in open_ids
        for o in _sell_orders[slug]
    )
    
    has_pending_stops = any(
        o.order_id in open_ids
        for o in _stop_loss_orders[slug]
    )
    
    if not has_pending_sells and not has_pending_stops:
        _states[slug] = StrategyState.COMPLETED
        _results[slug].end_time = time.time()
        
        notifier.send_cycle_report(_results[slug])
        return True
    
    return False

POR QU√â EST√Å AH√ç:
Necesitamos saber cu√°ndo un evento ha terminado para:
1. Liberar recursos (limpiar diccionarios)
2. Reportar resultados finales
3. Permitir que el scanner busque nuevos eventos

QU√â RESUELVE:
- OPTIMIZACI√ìN: Reutiliza open_ids cacheados de check_fills()
- Reporte final: Notifica PnL total del evento

-------------------------------------------------------------------------------
3.14. get_state(self, slug: str) -> Optional[StrategyState]
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 1047-1049

PROP√ìSITO:
Getter simple para obtener el estado de un evento.

L√ìGICA:
    return _states.get(slug)

POR QU√â EST√Å AH√ç:
Encapsulaci√≥n. Permite a main.py consultar el estado sin acceder
directamente al diccionario interno.

-------------------------------------------------------------------------------
3.15. get_result(self, slug: str) -> Optional[CycleResult]
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 1051-1053

PROP√ìSITO:
Getter simple para obtener el resultado del ciclo de un evento.

L√ìGICA:
    return _results.get(slug)

POR QU√â EST√Å AH√ç:
Encapsulaci√≥n para acceder a resultados de trading.

-------------------------------------------------------------------------------
3.16. get_pending_count(self, slug: str = None) -> int
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 1055-1065

PROP√ìSITO:
Cuenta √≥rdenes pendientes (no llenadas) para un evento o globalmente.

L√ìGICA:

    if slug:
        buys = len([o for o in _buy_orders[slug] if o not in _known_filled])
        sells = len([o for o in _sell_orders[slug] if o not in _known_filled])
        stops = len([o for o in _stop_loss_orders[slug] if o not in _known_filled])
        return buys + sells + stops
    else:
        # Sumar todos los eventos
        return sum(get_pending_count(s) for s in _states)

POR QU√â EST√Å AH√ç:
√ötil para logging y debugging. Permite ver cu√°ntas √≥rdenes est√°n activas.

================================================================================
4. CASOS L√çMITE Y SOLUCIONES IMPLEMENTADAS
================================================================================

4.1. BUG CR√çTICO: VENTA DE TODO EL BALANCE
------------------------------------------
PROBLEMA:
El bot intent√≥ vender 548 shares (balance total) en lugar de 68 shares
(lo que realmente hab√≠a acumulado del √∫ltimo fill).

CAUSA RA√çZ:
Durante una auditor√≠a anterior, se cambi√≥:
    sell_size = acc['size']  # Correcto: del acumulador
a:
    sell_size = available_balance  # INCORRECTO: todo el balance

SOLUCI√ìN IMPLEMENTADA (l√≠neas 734-770 de _process_buy_fill):
    # ‚ö†Ô∏è CR√çTICO: sell_size = acc['size'], NO total balance
    sell_size = acc['size']
    
    # Solo REDUCIR si available < sell_size
    if available_balance < sell_size:
        sell_size = truncate_6_decimals(available_balance)

PRINCIPIO:
- El acumulador es la FUENTE DE VERDAD de cu√°nto vender
- El balance se usa solo para VALIDACI√ìN y posible REDUCCI√ìN
- NUNCA reemplazar el sell_size con el balance total


4.2. TOKENS BLOQUEADOS EN √ìRDENES DE VENTA ABIERTAS
---------------------------------------------------
PROBLEMA:
Error "not enough balance" cuando hab√≠a 150 shares pero 100 ya estaban
en una orden de venta abierta.

SOLUCI√ìN IMPLEMENTADA (en m√∫ltiples funciones):
    open_orders = client.get_open_orders()
    locked_in_sells = sum(
        float(o.get("size", 0)) - float(o.get("size_matched", 0))
        for o in open_orders
        if o.get("asset_id") == token_id and o.get("side") == "SELL"
    )
    
    available_balance = actual_balance - locked_in_sells

UBICACIONES:
- _process_buy_fill: l√≠neas 742-755
- _flush_accumulator_for_event: l√≠neas 613-626
- process_pending_sells: l√≠neas 386-399


4.3. M√çNIMO DE ORDEN DIN√ÅMICO ($1 USDC)
---------------------------------------
PROBLEMA:
El bot usaba 5 shares m√≠nimo fijo, pero Polymarket requiere:
    Precio √ó Cantidad ‚â• $1 USDC (valor nocional)

A 49¬¢, 5 shares = $2.45 ‚úì
A 49¬¢, 2 shares = $0.98 ‚úó (rechazado por API)

SOLUCI√ìN IMPLEMENTADA (l√≠neas 710-714):
    min_shares_required = (MIN_NOTIONAL_VALUE_USDC / exit_price) * 1.01
    
    # 1.01 = margen de 1% para evitar rechazos por redondeo


4.4. ERRORES DE PRECISI√ìN FLOAT
-------------------------------
PROBLEMA:
Errores como:
    Balance: 100.00000001 shares
    Order: 100.00000002 shares
    ‚Üí "Insufficient balance"

SOLUCI√ìN IMPLEMENTADA (truncado a 6 decimales):
    sell_size = float(int(available_balance * 1000000)) / 1000000
    
    # Ejemplo: 100.00000001 ‚Üí int(100000000.01) ‚Üí 100000000 ‚Üí 100.0


4.5. RACE CONDITION EN CANCELACI√ìN
----------------------------------
PROBLEMA:
Al cancelar √≥rdenes de compra cuando evento pasa a LIVE, una orden
puede llenarse entre que enviamos cancel y se ejecuta.

SOLUCI√ìN IMPLEMENTADA (l√≠neas 988-994):
    cancelled = client.cancel_orders_batch(order_ids_to_cancel)
    
    if order_ids_to_cancel:
        self.audit_cancelled_orders(order_ids_to_cancel, event)


4.6. PARTIAL FILLS Y DOBLE CONTEO
---------------------------------
PROBLEMA:
Si una orden se llena parcialmente (10 de 50 shares), y luego m√°s
(20 de 50), proces√°bamos 10+20=30, no los 20 nuevos.

SOLUCI√ìN IMPLEMENTADA (l√≥gica delta):
    delta_fill = size_matched - order.processed_size
    
    if delta_fill > 0.000001:
        self._process_buy_fill(order, event, fill_amount=delta_fill)
        order.processed_size = size_matched  # Actualizar para siguiente check


4.7. SETTLEMENT DELAY (TOKENS NO DISPONIBLES)
---------------------------------------------
PROBLEMA:
Despu√©s de un fill, los tokens pueden tardar segundos en aparecer
en el balance on-chain.

SOLUCI√ìN IMPLEMENTADA (process_pending_sells):
    if actual_balance == 0:
        if pending['attempts'] <= 60:  # ~30 segundos
            still_pending.append(pending)
        else:
            notifier.send_message("Settlement timeout")


4.8. DUST (POSICIONES INVENDIBLES)
----------------------------------
PROBLEMA:
Si solo tenemos 1 share a 50¬¢, valor = $0.50 < $1 m√≠nimo.
No se puede vender, se pierde al expirar el mercado.

SOLUCI√ìN IMPLEMENTADA:
- Detectar y notificar: "DUST LOCKED - will expire worthless"
- Prevenir: Acumular hasta alcanzar m√≠nimo antes de vender
- Informar: Mensaje claro de cu√°ntas shares se necesitan


4.9. REINICIO DEL BOT MID-EVENTO
--------------------------------
PROBLEMA:
Si el bot se reinicia durante PRE_MARKET, podr√≠a colocar √≥rdenes
duplicadas.

SOLUCI√ìN IMPLEMENTADA (initialize_event, l√≠neas 100-162):
    existing_orders = client.get_open_orders()
    relevant_orders = [filtrar por token_id]
    
    if relevant_orders:
        # Recuperar en lugar de crear nuevas
        return recovered_count


4.10. API RETORNA None
----------------------
PROBLEMA:
La API de Polymarket a veces retorna None para √≥rdenes muy recientes.

SOLUCI√ìN IMPLEMENTADA (m√∫ltiples lugares):
    order_data = client.get_order(order.order_id)
    
    if order_data is None:
        continue  # Skip, reintentar en siguiente ciclo

================================================================================
5. FLUJO DE DATOS CR√çTICOS
================================================================================

5.1. FLUJO DE UN BUY FILL
-------------------------
1. check_fills() detecta size_matched > 0
2. Calcula delta = size_matched - order.processed_size
3. Llama _process_buy_fill(fill_amount=delta)
4. _process_buy_fill acumula en _fill_accumulator
5. Si acumulado >= m√≠nimo:
   a. sell_size = acc['size']  (del acumulador)
   b. Valida available_balance >= sell_size
   c. Coloca orden de venta o encola en pending_sells
6. Resetea acumulador

5.2. FLUJO DE TRANSICI√ìN A LIVE
-------------------------------
1. main.py detecta event.phase == LIVE
2. Llama transition_to_live(event)
3. Cancela todos los buys en batch
4. Audita √≥rdenes canceladas por race condition
5. Flush accumulator (procesa fills pendientes)
6. Cambia estado a EXITING
7. Notifica por Telegram

5.3. FLUJO DE PENDING SELLS
---------------------------
1. main.py llama process_pending_sells() una vez por ciclo
2. Para cada pending:
   a. Valida m√≠nimo nocional
   b. Intenta colocar orden
   c. Si falla: diagnostica (locked, settlement, balance)
   d. Decide: reintentar, ajustar tama√±o, o abandonar
3. Actualiza _pending_sells con los que siguen pendientes

================================================================================
6. CONCLUSIONES
================================================================================

6.1. ESTADO ACTUAL DEL C√ìDIGO
-----------------------------
‚úÖ CORRECTO: La l√≥gica central est√° bien implementada
‚úÖ CORRECTO: Todos los casos l√≠mite conocidos tienen manejo
‚úÖ CORRECTO: El bug cr√≠tico de sell_size ha sido corregido
‚úÖ CORRECTO: Notificaciones de Telegram con retry
‚úÖ CORRECTO: M√≠nimo din√°mico basado en valor nocional

6.2. PUNTOS DE ATENCI√ìN
-----------------------
‚ö†Ô∏è Hay una l√≠nea duplicada en _process_buy_fill (l√≠neas 780-781):
   logger.warning(f"‚ö†Ô∏è Balance check failed, using accumulator size: {e}")
   logger.warning(f"‚ö†Ô∏è Balance check failed, using accumulator: {e}")

6.3. RECOMENDACIONES
--------------------
1. Agregar tests unitarios para los casos l√≠mite
2. Considerar a√±adir m√©tricas de Prometheus/Grafana
3. Implementar circuit breaker si la API falla repetidamente
4. Agregar health check endpoint para monitoreo

================================================================================
                         FIN DEL INFORME DE AUDITOR√çA
================================================================================
