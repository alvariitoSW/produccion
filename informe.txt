================================================================================
                    INFORME DE AUDITOR√çA: strategy_engine.py
                    Bot de Trading Polymarket - Mean Reversion Ladder
                    Fecha: 4 de Febrero de 2026
================================================================================

√çNDICE
------
1. Resumen Ejecutivo
2. Arquitectura General
3. An√°lisis Funci√≥n por Funci√≥n
4. Casos L√≠mite y Soluciones Implementadas
5. Flujo de Datos Cr√≠ticos
6. Conclusiones

================================================================================
1. RESUMEN EJECUTIVO
================================================================================

El archivo strategy_engine.py implementa el n√∫cleo de la estrategia de trading
"Mean Reversion Ladder" para mercados de predicci√≥n en Polymarket.

ESTAD√çSTICAS:
- Total de l√≠neas: 1,065
- Funciones p√∫blicas: 8
- Funciones privadas: 7
- Estructuras de datos: 9 diccionarios de estado

PROBLEMAS CR√çTICOS RESUELTOS EN ESTA VERSI√ìN:
‚úÖ Bug cr√≠tico: Bot vend√≠a TODO el balance en lugar del acumulado
‚úÖ Tokens bloqueados: C√°lculo de locked_in_sells para √≥rdenes abiertas
‚úÖ M√≠nimo din√°mico: $1 USDC nocional en lugar de 5 shares fijas
‚úÖ Precisi√≥n float: Truncado a 6 decimales para evitar errores de balance
‚úÖ Race conditions: Auditor√≠a de √≥rdenes canceladas que pueden haber llenado
‚úÖ Partial fills: Procesamiento incremental con delta (no acumulativo)

================================================================================
2. ARQUITECTURA GENERAL
================================================================================

CLASE: StrategyEngine
---------------------
Responsabilidad: Gestionar la estrategia completa de trading para eventos
de Polymarket, incluyendo:
- Colocaci√≥n de escalera de √≥rdenes de compra (ladder)
- Detecci√≥n y procesamiento de fills
- Colocaci√≥n autom√°tica de √≥rdenes de venta (take-profit)
- Gesti√≥n de stop-loss client-side
- Recarga de posiciones en PRE_MARKET
- Transici√≥n a modo LIVE

ESTADOS DEL CICLO DE VIDA:
1. ACCUMULATING: Fase PRE_MARKET, comprando a precios bajos
2. EXITING: Evento LIVE, solo vendiendo posiciones
3. COMPLETED: Todas las ventas ejecutadas

ESTRUCTURAS DE DATOS PRINCIPALES:
---------------------------------
_states: Dict[str, StrategyState]
    ‚Üí Estado actual de cada evento (ACCUMULATING/EXITING/COMPLETED)

_positions: Dict[str, List[Position]]
    ‚Üí Posiciones abiertas por evento

_buy_orders: Dict[str, List[TrackedOrder]]
    ‚Üí √ìrdenes de compra colocadas por evento

_sell_orders: Dict[str, List[TrackedOrder]]
    ‚Üí √ìrdenes de venta (take-profit) por evento

_stop_loss_orders: Dict[str, List[TrackedOrder]]
    ‚Üí √ìrdenes de stop-loss por evento

_known_filled: Set[str]
    ‚Üí IDs de √≥rdenes ya procesadas (evita duplicados)

_pending_sells: List[Dict]
    ‚Üí Cola de ventas fallidas para reintentar

_fill_accumulator: Dict[tuple, Dict]
    ‚Üí Acumulador de fills parciales por (slug, side, token_id, exit_price)
    ‚Üí CR√çTICO: Clave incluye exit_price para separar entradas 47¬¢‚Üí48¬¢ de 48¬¢‚Üí49¬¢

================================================================================
3. AN√ÅLISIS FUNCI√ìN POR FUNCI√ìN
================================================================================

-------------------------------------------------------------------------------
3.1. __init__(self, client: PolymarketClient)
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 31-50

PROP√ìSITO:
Constructor de la clase. Inicializa todas las estructuras de datos necesarias
para el seguimiento del estado de la estrategia.

L√ìGICA:
1. Guarda referencia al cliente de Polymarket
2. Obtiene instancia del notificador de Telegram
3. Inicializa 9 diccionarios/sets vac√≠os para tracking de estado

POR QU√â EST√Å AH√ç:
Es el punto de entrada para crear una instancia del motor de estrategia.
Centraliza toda la inicializaci√≥n en un solo lugar.

QU√â RESUELVE:
- Evita errores de KeyError al acceder a diccionarios no inicializados
- Garantiza estado limpio al crear nueva instancia

-------------------------------------------------------------------------------
3.2. _get_exit_price(self, entry_price: float) -> float
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 52-62

PROP√ìSITO:
Determina el precio de salida (take-profit) basado en el precio de entrada.

L√ìGICA:
1. Redondea el precio de entrada a 2 decimales (evita errores de precisi√≥n float)
2. Busca en diccionario EXIT_PRICES el precio de salida correspondiente
3. Retorna 49¬¢ por defecto si no encuentra mapeo

MAPEO DE PRECIOS (desde config.py):
- Entrada 48¬¢ ‚Üí Salida 49¬¢ (spread 1¬¢ = 2.08% profit)
- Entrada 46-47¬¢ ‚Üí Salida 48¬¢ (spread 1-2¬¢)
- Entrada 40-45¬¢ ‚Üí Salida 47¬¢ (spread 2-7¬¢)

POR QU√â EST√Å AH√ç:
La estrategia de mean reversion requiere spreads din√°micos. Entradas m√°s
arriesgadas (precios bajos) deben tener mayor spread de protecci√≥n.

QU√â RESUELVE:
- Centraliza la l√≥gica de mapeo entry‚Üíexit
- El redondeo a 2 decimales evita bugs como 0.4799999999 != 0.48

-------------------------------------------------------------------------------
3.3. _needs_stop_loss(self, entry_price: float) -> bool
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 64-67

PROP√ìSITO:
Determina si una entrada necesita stop-loss basado en su precio.

L√ìGICA:
1. Redondea precio a 2 decimales
2. Verifica si est√° en el set STOP_LOSS_ENTRIES (t√≠picamente solo 48¬¢)

POR QU√â EST√Å AH√ç:
Las entradas a 48¬¢ son las m√°s arriesgadas (cerca del 50%). Si el mercado
se mueve en contra, la p√©rdida potencial es mayor. Solo estas necesitan
protecci√≥n adicional con stop-loss.

QU√â RESUELVE:
- Evita colocar stop-loss innecesarios en entradas seguras (40-47¬¢)
- Reduce complejidad de la l√≥gica OCO (One-Cancels-Other)

-------------------------------------------------------------------------------
3.4. initialize_event(self, event: EventContext) -> int
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 69-186

PROP√ìSITO:
Inicializa la estrategia para un nuevo evento. Coloca la escalera de √≥rdenes
de compra o recupera √≥rdenes existentes si el bot se reinici√≥.

L√ìGICA DETALLADA:

FASE 1 - VALIDACI√ìN (l√≠neas 78-90):
    if slug in self._states:
        return 0  # Ya inicializado
    
    if event.phase != MarketPhase.PRE_MARKET:
        logger.error("REJECTED: Solo PRE_MARKET permitido")
        return 0

FASE 2 - INICIALIZACI√ìN DE ESTADO (l√≠neas 92-98):
    self._states[slug] = StrategyState.ACCUMULATING
    self._positions[slug] = []
    self._results[slug] = CycleResult(...)
    self._buy_orders[slug] = []
    self._sell_orders[slug] = []
    self._stop_loss_orders[slug] = []

FASE 3 - RECUPERACI√ìN DE ESTADO (l√≠neas 100-162):
    existing_orders = self.client.get_open_orders()
    relevant_orders = [filtrar por token_id del evento]
    
    if relevant_orders:
        # Reconstruir TrackedOrder desde datos de API
        # Agregar a _buy_orders o _sell_orders seg√∫n tipo
        return recovered_count  # NO colocar nuevas √≥rdenes

FASE 4 - COLOCACI√ìN DE LADDER (l√≠neas 164-186):
    for side in [YES, NO]:
        for price in LADDER_LEVELS:  # [0.40, 0.42, ..., 0.48]
            order = client.place_limit_order(...)
            _buy_orders[slug].append(order)

POR QU√â EST√Å AH√ç:
Es el punto de entrada para comenzar a operar un nuevo evento. Debe:
1. Prevenir inicializaci√≥n doble
2. Rechazar eventos que ya est√°n LIVE
3. Recuperar estado si el bot se reinici√≥ mid-evento

QU√â RESUELVE:
- CASO L√çMITE: Reinicio del bot ‚Üí No coloca √≥rdenes duplicadas
- CASO L√çMITE: Evento ya LIVE ‚Üí Rechazado para evitar p√©rdidas
- Idempotencia: Llamar m√∫ltiples veces es seguro

-------------------------------------------------------------------------------
3.5. check_fills(self, event: EventContext, open_order_ids: Optional[Set[str]]) 
     -> Optional[Set[str]]
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 188-316

PROP√ìSITO:
Detecta y procesa √≥rdenes que han sido llenadas (parcial o totalmente).
Es el "coraz√≥n" del sistema de detecci√≥n de fills.

L√ìGICA DETALLADA:

SECCI√ìN 1 - VERIFICACI√ìN DE COMPRAS (l√≠neas 215-270):

    # Optimizaci√≥n: Ordenar por precio DESC (48¬¢ primero)
    active_buys_sorted = sorted(active_buys, key=lambda o: o.price, reverse=True)
    
    for order in active_buys_sorted:
        # OPTIMIZACI√ìN: Solo consultar API si:
        # 1. Orden desapareci√≥ de open_order_ids (probable fill)
        # 2. Orden es "alta prioridad" (‚â•46¬¢) - revisar siempre
        
        if not (order_missing or is_high_priority):
            continue  # Skip √≥rdenes de baja prioridad que siguen abiertas
        
        order_data = client.get_order(order.order_id)
        size_matched = float(order_data.get("size_matched", 0))
        
        # CR√çTICO: Procesar solo el DELTA (nuevo desde √∫ltima revisi√≥n)
        delta_fill = size_matched - order.processed_size
        
        if delta_fill > 0.000001:
            safe_delta = round(delta_fill, 6)
            self._process_buy_fill(order, event, fill_amount=safe_delta)
            order.processed_size = size_matched  # Actualizar para siguiente ciclo

SECCI√ìN 2 - VERIFICACI√ìN DE VENTAS (l√≠neas 272-304):

    for order in _sell_orders[slug]:
        if order.order_id not in open_order_ids:
            # Orden desapareci√≥ ‚Üí probable fill
            order_data = client.get_order(order.order_id)
            
            # SAFETY: Validar que API retorn√≥ datos
            if order_data is None:
                continue  # Reintentar en siguiente ciclo
            
            if size_matched > 0:
                self._process_sell_fill(order, event)
            
            # PARTIAL FILL: Solo marcar como _known_filled si est√° 100% lleno
            if size_matched >= original_size:
                _known_filled.add(order.order_id)

SECCI√ìN 3 - MONITOR DE STOP-LOSS (l√≠neas 306-312):

    self._check_stop_loss(event, open_order_ids)

SECCI√ìN 4 - RETORNO DE IDs CACHEADOS (l√≠nea 316):

    return open_order_ids  # Reusar en check_completion()

POR QU√â EST√Å AH√ç:
Sin detecci√≥n de fills, el bot no sabr√≠a cu√°ndo colocar √≥rdenes de venta.
Es el sistema de "sensores" que detecta actividad en el mercado.

QU√â RESUELVE:
- CASO L√çMITE: Partial fills ‚Üí Usa delta, no acumulativo
- CASO L√çMITE: API retorna None ‚Üí Skip seguro, reintenta despu√©s
- CASO L√çMITE: Orden de alta prioridad (48¬¢) ‚Üí Revisar cada ciclo
- OPTIMIZACI√ìN: No consultar API para √≥rdenes de baja prioridad que siguen abiertas

-------------------------------------------------------------------------------
3.6. process_pending_sells(self) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 318-481

PROP√ìSITO:
Reintenta colocar √≥rdenes de venta que fallaron anteriormente.
Llamada UNA VEZ por ciclo desde main.py (no por evento).

L√ìGICA DETALLADA:

FASE 1 - VALIDACI√ìN DE DUST (l√≠neas 330-345):

    notional_value = pending['size'] * pending['exit_price']
    
    if notional_value < MIN_NOTIONAL_VALUE_USDC:  # $1 m√≠nimo
        logger.error("DUST REJECTED: No cumple m√≠nimo nocional")
        continue  # No reintentar, siempre fallar√°

FASE 2 - INTENTO DE COLOCACI√ìN (l√≠neas 347-373):

    sell_order = client.place_limit_order(...)
    
    if sell_order:
        _sell_orders[slug].append(sell_order)
        notifier.send_sell_placed(...)
    else:
        # Fall√≥ ‚Üí investigar por qu√©

FASE 3 - DIAGN√ìSTICO INTELIGENTE DE FALLO (l√≠neas 375-481):

    actual_balance = client.get_token_balance(token_id)
    
    # ‚ö†Ô∏è CR√çTICO: Calcular tokens bloqueados en ventas abiertas
    open_orders = client.get_open_orders()
    locked_in_sells = sum(
        size - size_matched
        for o in open_orders
        if o.asset_id == token_id and o.side == "SELL"
    )
    
    available_balance = actual_balance - locked_in_sells
    
    ESCENARIOS:
    
    A) available_balance <= 0:
        ‚Üí Tokens bloqueados en otras ventas
        ‚Üí Verificar si ya existe orden duplicada
        ‚Üí Si existe: remover de pending
        ‚Üí Si no: reintentar brevemente (5 intentos max)
    
    B) actual_balance == 0:
        ‚Üí Delay de settlement (tokens no en blockchain a√∫n)
        ‚Üí Reintentar hasta 60 intentos (~30 segundos)
        ‚Üí Despu√©s: alertar por Telegram
    
    C) 0 < available_balance < pending['size']:
        ‚Üí Balance parcial disponible
        ‚Üí Ajustar size al disponible (truncar a 6 decimales)
        ‚Üí Validar que ajustado cumple m√≠nimo nocional
    
    D) available_balance >= pending['size']:
        ‚Üí Tenemos suficiente pero API fall√≥
        ‚Üí Reintentar hasta 10 intentos
        ‚Üí Despu√©s: alertar cr√≠tica por Telegram

POR QU√â EST√Å AH√ç:
Las √≥rdenes de venta pueden fallar por m√∫ltiples razones:
- Settlement delay: tokens no disponibles inmediatamente
- Balance insuficiente: ya vendido por otra orden
- Error de API: timeout, rate limit, etc.

QU√â RESUELVE:
- CASO L√çMITE: Settlement delay ‚Üí Reintento con timeout de 30s
- CASO L√çMITE: Tokens bloqueados ‚Üí Detecta y evita duplicados
- CASO L√çMITE: Balance parcial ‚Üí Ajusta tama√±o autom√°ticamente
- CASO L√çMITE: Dust ‚Üí Rechaza si no cumple $1 m√≠nimo

-------------------------------------------------------------------------------
3.7. _check_stop_loss(self, event: EventContext, open_order_ids: set) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 483-551

PROP√ìSITO:
Monitor client-side de stop-loss para entradas de alto riesgo (48¬¢).
Si el precio cae a STOP_LOSS_PRICE (ej: 18¬¢), ejecuta venta a mercado.

L√ìGICA DETALLADA:

    for order in _sell_orders[slug]:
        # Skip si ya procesado o ya llenado
        if order.order_id in _known_filled or order.order_id not in open_order_ids:
            continue
        
        # Solo aplicar a entradas que necesitan stop-loss (48¬¢)
        if not _needs_stop_loss(order.entry_price):
            continue
        
        # Obtener precio actual del mercado (best bid)
        current_market_price = event.yes_bid o event.no_bid
        
        # TRIGGER: Si precio cae al umbral
        if current_market_price <= STOP_LOSS_PRICE:
            
            # 1. Cancelar orden de take-profit (liberar tokens)
            client.cancel_order(order.order_id)
            _known_filled.add(order.order_id)
            
            # 2. Vender a mercado (limit a 1¬¢ cruza cualquier bid)
            dump_order = client.place_limit_order(
                price=0.01,  # "Market sell"
                size=order.size,
                ...
            )
            
            # 3. Notificar
            if dump_order:
                notifier.send_message("STOP-LOSS EJECUTADO")
            else:
                notifier.send_message("ALERTA: Stop-loss fall√≥")

POR QU√â EST√Å AH√ç:
Polymarket no tiene √≥rdenes stop-loss nativas. Debemos implementar
monitoreo client-side para proteger posiciones de alto riesgo.

QU√â RESUELVE:
- CASO L√çMITE: Mercado colapsa ‚Üí Vende antes de p√©rdida total
- CASO L√çMITE: Solo 48¬¢ ‚Üí No afecta entradas m√°s seguras
- CASO L√çMITE: Tokens bloqueados ‚Üí Cancela TP antes de vender

-------------------------------------------------------------------------------
3.8. _flush_accumulator_for_event(self, event: EventContext) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 553-656

PROP√ìSITO:
Vac√≠a el acumulador de fills parciales cuando el evento pasa a LIVE.
Intenta vender lo acumulado si cumple m√≠nimo, o marca como "dust" si no.

L√ìGICA DETALLADA:

    # Encontrar todas las claves del acumulador para este evento
    keys_to_flush = [k for k in _fill_accumulator.keys() if k[0] == slug]
    
    for acc_key in keys_to_flush:
        acc = _fill_accumulator[acc_key]
        
        if acc['size'] > 0.001:  # Tama√±o significativo
            _, side, token_id, exit_price = acc_key
            sell_size = acc['size']  # ‚ö†Ô∏è CR√çTICO: Usar tama√±o del acumulador
            
            # Calcular valor nocional
            notional_value = sell_size * exit_price
            
            if notional_value < MIN_NOTIONAL_VALUE_USDC:
                # DUST: No se puede vender
                logger.error("DUST LOCKED: Expirar√° sin valor")
                notifier.send_message("DUST LOCKED...")
                _fill_accumulator[acc_key] = {'size': 0.0, ...}
                continue
            
            # üõ°Ô∏è SAFETY: Verificar balance disponible
            actual_balance = client.get_token_balance(token_id)
            
            # Calcular tokens bloqueados en ventas abiertas
            locked_in_sells = sum(...)
            available_balance = actual_balance - locked_in_sells
            
            # ‚ö†Ô∏è CR√çTICO: Solo REDUCIR si necesario, no REEMPLAZAR
            if available_balance < sell_size:
                if available_balance <= 0:
                    continue  # Todo bloqueado
                sell_size = truncate_6_decimals(available_balance)
            
            # Agregar a cola de pending sells
            _pending_sells.append({
                'token_id': token_id,
                'size': sell_size,  # Tama√±o del acumulador (posiblemente reducido)
                ...
            })
            
            # Limpiar acumulador
            _fill_accumulator[acc_key] = {'size': 0.0, 'total_entry_value': 0.0}

POR QU√â EST√Å AH√ç:
Durante PRE_MARKET, pueden llegar partial fills que no cumplen el m√≠nimo
de $1 USDC individualmente. El acumulador los junta hasta que cumplen.
Cuando el evento pasa a LIVE, debemos procesar lo que qued√≥ acumulado.

QU√â RESUELVE:
- CASO L√çMITE: Partial fills peque√±os ‚Üí Acumula hasta cumplir m√≠nimo
- CASO L√çMITE: Dust al pasar a LIVE ‚Üí Notifica que se perder√°
- CASO L√çMITE: Tokens bloqueados ‚Üí Reduce tama√±o o skip
- BUG CR√çTICO RESUELTO: Usaba balance total, ahora usa acc['size']

-------------------------------------------------------------------------------
3.9. _process_buy_fill(self, order: TrackedOrder, event: EventContext, 
                        fill_amount: Optional[float] = None) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 658-821

PROP√ìSITO:
Procesa un fill de compra. Acumula shares y coloca orden de venta cuando
se alcanza el m√≠nimo de $1 USDC nocional.

L√ìGICA DETALLADA:

FASE 1 - PREPARACI√ìN (l√≠neas 664-680):

    entry_price = order.price
    exit_price = _get_exit_price(entry_price)
    actual_size = fill_amount or order.size
    
    # Notificar por Telegram
    notifier.send_message("BUY FILLED...")
    
    # Registrar posici√≥n
    _positions[slug].append(Position(...))
    _results[slug].fills_yes/no.append(entry_price)

FASE 2 - ACUMULACI√ìN (l√≠neas 700-725):

    # Calcular m√≠nimo de shares para cumplir $1 USDC
    min_shares_required = (MIN_NOTIONAL_VALUE_USDC / exit_price) * 1.01
    
    # Clave del acumulador incluye exit_price
    # ‚Üí Separa entradas 47¬¢‚Üí48¬¢ de 48¬¢‚Üí49¬¢
    acc_key = (slug, order.side, order.token_id, exit_price)
    
    # Acumular
    acc['size'] += actual_size
    acc['total_entry_value'] += actual_size * entry_price
    
    logger.info(f"Accumulated: {acc['size']} shares (need {min_shares_required})")

FASE 3 - DECISI√ìN DE VENTA (l√≠neas 727-821):

    SELL_THRESHOLD = min_shares_required * 0.99  # 99% para partial fills
    
    if acc['size'] >= SELL_THRESHOLD:
        avg_entry = acc['total_entry_value'] / acc['size']
        
        # ‚ö†Ô∏è CR√çTICO: sell_size = acc['size'], NO total balance
        sell_size = acc['size']
        
        # üõ°Ô∏è SAFETY: Verificar balance disponible
        actual_balance = client.get_token_balance(token_id)
        
        # Calcular locked_in_sells
        locked_in_sells = sum(
            size - size_matched
            for o in open_orders
            if o.asset_id == token_id and o.side == "SELL"
        )
        
        available_balance = actual_balance - locked_in_sells
        
        # ‚ö†Ô∏è CR√çTICO: Solo REDUCIR si necessary
        if available_balance < sell_size:
            if available_balance <= 0:
                return  # No limpiar acumulador, reintentar despu√©s
            sell_size = truncate_6_decimals(available_balance)
        
        # Validar m√≠nimo nocional
        if sell_size * exit_price < MIN_NOTIONAL_VALUE_USDC:
            logger.error("DUST")
            _fill_accumulator[acc_key] = {'size': 0.0, ...}
            return
        
        # Limpiar acumulador
        _fill_accumulator[acc_key] = {'size': 0.0, 'total_entry_value': 0.0}
        
        # Colocar orden de venta
        sell_order = client.place_limit_order(
            price=exit_price,
            size=sell_size,  # Del acumulador, no del balance total
            ...
        )
        
        if sell_order:
            _sell_orders[slug].append(sell_order)
            notifier.send_sell_placed(...)
        else:
            _pending_sells.append(...)  # Reintentar despu√©s

POR QU√â EST√Å AH√ç:
Es el core de la estrategia: cuando compramos, debemos vender a profit.
Sin esta funci√≥n, el bot comprar√≠a pero nunca vender√≠a.

QU√â RESUELVE:
- CASO L√çMITE: Partial fills < $1 ‚Üí Acumula hasta cumplir
- CASO L√çMITE: Tokens bloqueados ‚Üí Reduce tama√±o o espera
- BUG CR√çTICO RESUELTO: Antes usaba available_balance como sell_size
  (vend√≠a TODO el balance), ahora usa acc['size'] (solo lo acumulado)
- CASO L√çMITE: API falla ‚Üí Cola de pending_sells para retry

-------------------------------------------------------------------------------
3.10. audit_cancelled_orders(self, order_ids: List[str], event: EventContext)
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 823-884

PROP√ìSITO:
Audita √≥rdenes de compra que fueron canceladas para detectar fills ocultos
que ocurrieron durante la "race condition" de cancelaci√≥n.

L√ìGICA DETALLADA:

    logger.info(f"Auditing {len(order_ids)} cancelled orders...")
    
    # Encontrar TrackedOrders correspondientes
    orders_to_audit = [
        o for o in _buy_orders[slug]
        if o.order_id in order_ids
    ]
    
    for order in orders_to_audit:
        order_data = client.get_order(order.order_id)
        
        # SAFETY: Validar que API retorn√≥ datos
        if not order_data:
            continue
        
        size_matched = float(order_data.get("size_matched", 0))
        
        if size_matched > 0:
            # DELTA logic: Solo procesar fills nuevos
            delta_fill = size_matched - order.processed_size
            
            if delta_fill > 0.000001:
                logger.warning(f"RACE CONDITION: Found {delta_fill} hidden shares!")
                
                safe_delta = round(delta_fill, 6)
                self._process_buy_fill(order, event, fill_amount=safe_delta)
                order.processed_size = size_matched
            
            if size_matched >= original_size:
                _known_filled.add(order.order_id)

POR QU√â EST√Å AH√ç:
Cuando el evento pasa a LIVE, cancelamos todas las √≥rdenes de compra en batch.
Pero entre que enviamos la cancelaci√≥n y se ejecuta, alguna orden puede haber
sido llenada. Sin esta auditor√≠a, perder√≠amos esos fills.

QU√â RESUELVE:
- CASO L√çMITE: Race condition en cancelaci√≥n ‚Üí Detecta fills ocultos
- CASO L√çMITE: API retorna None ‚Üí Skip seguro
- CASO L√çMITE: Fill ya procesado parcialmente ‚Üí Usa delta, no acumulativo

-------------------------------------------------------------------------------
3.11. _process_sell_fill(self, order: TrackedOrder, event: EventContext,
                          is_stop_loss: bool = False) -> None
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 886-964

PROP√ìSITO:
Procesa un fill de venta (take-profit o stop-loss). Calcula PnL, ejecuta
l√≥gica OCO, y opcionalmente recarga la posici√≥n si est√° en PRE_MARKET.

L√ìGICA DETALLADA:

FASE 1 - C√ÅLCULO DE PnL (l√≠neas 895-912):

    entry_price = order.entry_price or 0
    pnl = (order.price - entry_price) * order.size
    _results[slug].total_pnl += pnl
    
    if is_stop_loss:
        logger.warning("STOP-LOSS HIT: Loss $X")
    else:
        logger.info("TAKE-PROFIT: PnL $X")

FASE 2 - L√ìGICA OCO (l√≠neas 914-938):

    # Solo para entradas que tienen stop-loss (48¬¢)
    if _needs_stop_loss(entry_price):
        
        if is_stop_loss:
            # Stop-loss ejecutado ‚Üí Cancelar take-profit
            for sell in _sell_orders[slug]:
                if sell.entry_price ‚âà entry_price:
                    client.cancel_order(sell.order_id)
                    _known_filled.add(sell.order_id)
                    break
        else:
            # Take-profit ejecutado ‚Üí Cancelar stop-loss
            for stop in _stop_loss_orders[slug]:
                if stop.entry_price ‚âà entry_price:
                    client.cancel_order(stop.order_id)
                    _known_filled.add(stop.order_id)
                    break

FASE 3 - LIMPIEZA DE POSICI√ìN (l√≠neas 940-948):

    for pos in _positions[slug]:
        if pos.side == order.side and pos.entry_price ‚âà entry_price:
            _positions[slug].remove(pos)
            break
    
    notifier.send_fill(order, pnl=pnl)

FASE 4 - RELOAD EN PRE_MARKET (l√≠neas 950-964):

    # Solo si estamos en ACCUMULATING (PRE_MARKET) y NO es stop-loss
    if _states[slug] == StrategyState.ACCUMULATING and not is_stop_loss:
        reload_order = client.place_limit_order(
            price=entry_price,  # Mismo precio que antes
            size=order.size,
            type=BUY
        )
        
        if reload_order:
            _buy_orders[slug].append(reload_order)
            logger.info("RELOAD: Replenished buy")

POR QU√â EST√Å AH√ç:
Completa el ciclo de trading. Cuando vendemos, necesitamos:
1. Calcular si ganamos o perdimos dinero
2. Cancelar √≥rdenes relacionadas (OCO)
3. Limpiar estado interno
4. Recargar si hay oportunidad (PRE_MARKET)

QU√â RESUELVE:
- CASO L√çMITE: OCO ‚Üí Evita que queden √≥rdenes hu√©rfanas
- CASO L√çMITE: Stop-loss no recarga ‚Üí Evita perseguir p√©rdidas
- CASO L√çMITE: PRE_MARKET ‚Üí Aprovecha oportunidades de reload

-------------------------------------------------------------------------------
3.12. transition_to_live(self, event: EventContext) -> int
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 966-1006

PROP√ìSITO:
Maneja la transici√≥n del evento de PRE_MARKET a LIVE.
Cancela todas las √≥rdenes de compra y prepara para modo solo-salida.

L√ìGICA DETALLADA:

    if _states[slug] != StrategyState.ACCUMULATING:
        return 0  # Ya transicionado o no inicializado
    
    # Recolectar IDs de √≥rdenes a cancelar
    order_ids_to_cancel = [
        o.order_id for o in _buy_orders[slug]
        if o.order_id not in _known_filled
    ]
    
    # Cancelaci√≥n en batch (una llamada API)
    cancelled = client.cancel_orders_batch(order_ids_to_cancel)
    
    # üõ°Ô∏è AUDITOR√çA DE RACE CONDITION
    if order_ids_to_cancel:
        self.audit_cancelled_orders(order_ids_to_cancel, event)
    
    # üì¶ FLUSH ACCUMULATOR
    self._flush_accumulator_for_event(event)
    
    # Cambiar estado
    _states[slug] = StrategyState.EXITING
    
    notifier.send_phase_transition(event, cancelled)
    return cancelled

POR QU√â EST√Å AH√ç:
Cuando el evento pasa a LIVE, las probabilidades ya no son favorables
para comprar. Debemos:
1. Cancelar compras pendientes (ya no queremos m√°s posiciones)
2. Detectar fills de √∫ltima hora (race condition)
3. Procesar cualquier acumulaci√≥n pendiente
4. Cambiar a modo "solo venta"

QU√â RESUELVE:
- CASO L√çMITE: Race condition ‚Üí Audita √≥rdenes canceladas
- CASO L√çMITE: Fills acumulados ‚Üí Flush antes de cambiar modo
- OPTIMIZACI√ìN: Batch cancel ‚Üí Una llamada API en lugar de N

-------------------------------------------------------------------------------
3.13. check_completion(self, event: EventContext, cached_open_ids: set) -> bool
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 1008-1045

PROP√ìSITO:
Verifica si la estrategia est√° completa para un evento.
Completo = modo EXITING + sin √≥rdenes de venta abiertas.

L√ìGICA:

    if _states[slug] != StrategyState.EXITING:
        return False  # A√∫n no en modo salida
    
    # Usar IDs cacheados si disponibles (optimizaci√≥n)
    open_ids = cached_open_ids or {fetch from API}
    
    has_pending_sells = any(
        o.order_id in open_ids
        for o in _sell_orders[slug]
    )
    
    has_pending_stops = any(
        o.order_id in open_ids
        for o in _stop_loss_orders[slug]
    )
    
    if not has_pending_sells and not has_pending_stops:
        _states[slug] = StrategyState.COMPLETED
        _results[slug].end_time = time.time()
        
        notifier.send_cycle_report(_results[slug])
        return True
    
    return False

POR QU√â EST√Å AH√ç:
Necesitamos saber cu√°ndo un evento ha terminado para:
1. Liberar recursos (limpiar diccionarios)
2. Reportar resultados finales
3. Permitir que el scanner busque nuevos eventos

QU√â RESUELVE:
- OPTIMIZACI√ìN: Reutiliza open_ids cacheados de check_fills()
- Reporte final: Notifica PnL total del evento

-------------------------------------------------------------------------------
3.14. get_state(self, slug: str) -> Optional[StrategyState]
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 1047-1049

PROP√ìSITO:
Getter simple para obtener el estado de un evento.

L√ìGICA:
    return _states.get(slug)

POR QU√â EST√Å AH√ç:
Encapsulaci√≥n. Permite a main.py consultar el estado sin acceder
directamente al diccionario interno.

-------------------------------------------------------------------------------
3.15. get_result(self, slug: str) -> Optional[CycleResult]
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 1051-1053

PROP√ìSITO:
Getter simple para obtener el resultado del ciclo de un evento.

L√ìGICA:
    return _results.get(slug)

POR QU√â EST√Å AH√ç:
Encapsulaci√≥n para acceder a resultados de trading.

-------------------------------------------------------------------------------
3.16. get_pending_count(self, slug: str = None) -> int
-------------------------------------------------------------------------------
UBICACI√ìN: L√≠neas 1055-1065

PROP√ìSITO:
Cuenta √≥rdenes pendientes (no llenadas) para un evento o globalmente.

L√ìGICA:

    if slug:
        buys = len([o for o in _buy_orders[slug] if o not in _known_filled])
        sells = len([o for o in _sell_orders[slug] if o not in _known_filled])
        stops = len([o for o in _stop_loss_orders[slug] if o not in _known_filled])
        return buys + sells + stops
    else:
        # Sumar todos los eventos
        return sum(get_pending_count(s) for s in _states)

POR QU√â EST√Å AH√ç:
√ötil para logging y debugging. Permite ver cu√°ntas √≥rdenes est√°n activas.

================================================================================
4. CASOS L√çMITE Y SOLUCIONES IMPLEMENTADAS
================================================================================

4.1. BUG CR√çTICO: VENTA DE TODO EL BALANCE
------------------------------------------
PROBLEMA:
El bot intent√≥ vender 548 shares (balance total) en lugar de 68 shares
(lo que realmente hab√≠a acumulado del √∫ltimo fill).

CAUSA RA√çZ:
Durante una auditor√≠a anterior, se cambi√≥:
    sell_size = acc['size']  # Correcto: del acumulador
a:
    sell_size = available_balance  # INCORRECTO: todo el balance

SOLUCI√ìN IMPLEMENTADA (l√≠neas 734-770 de _process_buy_fill):
    # ‚ö†Ô∏è CR√çTICO: sell_size = acc['size'], NO total balance
    sell_size = acc['size']
    
    # Solo REDUCIR si available < sell_size
    if available_balance < sell_size:
        sell_size = truncate_6_decimals(available_balance)

PRINCIPIO:
- El acumulador es la FUENTE DE VERDAD de cu√°nto vender
- El balance se usa solo para VALIDACI√ìN y posible REDUCCI√ìN
- NUNCA reemplazar el sell_size con el balance total


4.2. TOKENS BLOQUEADOS EN √ìRDENES DE VENTA ABIERTAS
---------------------------------------------------
PROBLEMA:
Error "not enough balance" cuando hab√≠a 150 shares pero 100 ya estaban
en una orden de venta abierta.

SOLUCI√ìN IMPLEMENTADA (en m√∫ltiples funciones):
    open_orders = client.get_open_orders()
    locked_in_sells = sum(
        float(o.get("size", 0)) - float(o.get("size_matched", 0))
        for o in open_orders
        if o.get("asset_id") == token_id and o.get("side") == "SELL"
    )
    
    available_balance = actual_balance - locked_in_sells

UBICACIONES:
- _process_buy_fill: l√≠neas 742-755
- _flush_accumulator_for_event: l√≠neas 613-626
- process_pending_sells: l√≠neas 386-399


4.3. M√çNIMO DE ORDEN DIN√ÅMICO ($1 USDC)
---------------------------------------
PROBLEMA:
El bot usaba 5 shares m√≠nimo fijo, pero Polymarket requiere:
    Precio √ó Cantidad ‚â• $1 USDC (valor nocional)

A 49¬¢, 5 shares = $2.45 ‚úì
A 49¬¢, 2 shares = $0.98 ‚úó (rechazado por API)

SOLUCI√ìN IMPLEMENTADA (l√≠neas 710-714):
    min_shares_required = (MIN_NOTIONAL_VALUE_USDC / exit_price) * 1.01
    
    # 1.01 = margen de 1% para evitar rechazos por redondeo


4.4. ERRORES DE PRECISI√ìN FLOAT
-------------------------------
PROBLEMA:
Errores como:
    Balance: 100.00000001 shares
    Order: 100.00000002 shares
    ‚Üí "Insufficient balance"

SOLUCI√ìN IMPLEMENTADA (truncado a 6 decimales):
    sell_size = float(int(available_balance * 1000000)) / 1000000
    
    # Ejemplo: 100.00000001 ‚Üí int(100000000.01) ‚Üí 100000000 ‚Üí 100.0


4.5. RACE CONDITION EN CANCELACI√ìN
----------------------------------
PROBLEMA:
Al cancelar √≥rdenes de compra cuando evento pasa a LIVE, una orden
puede llenarse entre que enviamos cancel y se ejecuta.

SOLUCI√ìN IMPLEMENTADA (l√≠neas 988-994):
    cancelled = client.cancel_orders_batch(order_ids_to_cancel)
    
    if order_ids_to_cancel:
        self.audit_cancelled_orders(order_ids_to_cancel, event)


4.6. PARTIAL FILLS Y DOBLE CONTEO
---------------------------------
PROBLEMA:
Si una orden se llena parcialmente (10 de 50 shares), y luego m√°s
(20 de 50), proces√°bamos 10+20=30, no los 20 nuevos.

SOLUCI√ìN IMPLEMENTADA (l√≥gica delta):
    delta_fill = size_matched - order.processed_size
    
    if delta_fill > 0.000001:
        self._process_buy_fill(order, event, fill_amount=delta_fill)
        order.processed_size = size_matched  # Actualizar para siguiente check


4.7. SETTLEMENT DELAY (TOKENS NO DISPONIBLES)
---------------------------------------------
PROBLEMA:
Despu√©s de un fill, los tokens pueden tardar segundos en aparecer
en el balance on-chain.

SOLUCI√ìN IMPLEMENTADA (process_pending_sells):
    if actual_balance == 0:
        if pending['attempts'] <= 60:  # ~30 segundos
            still_pending.append(pending)
        else:
            notifier.send_message("Settlement timeout")


4.8. DUST (POSICIONES INVENDIBLES)
----------------------------------
PROBLEMA:
Si solo tenemos 1 share a 50¬¢, valor = $0.50 < $1 m√≠nimo.
No se puede vender, se pierde al expirar el mercado.

SOLUCI√ìN IMPLEMENTADA:
- Detectar y notificar: "DUST LOCKED - will expire worthless"
- Prevenir: Acumular hasta alcanzar m√≠nimo antes de vender
- Informar: Mensaje claro de cu√°ntas shares se necesitan


4.9. REINICIO DEL BOT MID-EVENTO
--------------------------------
PROBLEMA:
Si el bot se reinicia durante PRE_MARKET, podr√≠a colocar √≥rdenes
duplicadas.

SOLUCI√ìN IMPLEMENTADA (initialize_event, l√≠neas 100-162):
    existing_orders = client.get_open_orders()
    relevant_orders = [filtrar por token_id]
    
    if relevant_orders:
        # Recuperar en lugar de crear nuevas
        return recovered_count


4.10. API RETORNA None
----------------------
PROBLEMA:
La API de Polymarket a veces retorna None para √≥rdenes muy recientes.

SOLUCI√ìN IMPLEMENTADA (m√∫ltiples lugares):
    order_data = client.get_order(order.order_id)
    
    if order_data is None:
        continue  # Skip, reintentar en siguiente ciclo

================================================================================
5. FLUJO DE DATOS CR√çTICOS
================================================================================

5.1. FLUJO DE UN BUY FILL
-------------------------
1. check_fills() detecta size_matched > 0
2. Calcula delta = size_matched - order.processed_size
3. Llama _process_buy_fill(fill_amount=delta)
4. _process_buy_fill acumula en _fill_accumulator
5. Si acumulado >= m√≠nimo:
   a. sell_size = acc['size']  (del acumulador)
   b. Valida available_balance >= sell_size
   c. Coloca orden de venta o encola en pending_sells
6. Resetea acumulador

5.2. FLUJO DE TRANSICI√ìN A LIVE
-------------------------------
1. main.py detecta event.phase == LIVE
2. Llama transition_to_live(event)
3. Cancela todos los buys en batch
4. Audita √≥rdenes canceladas por race condition
5. Flush accumulator (procesa fills pendientes)
6. Cambia estado a EXITING
7. Notifica por Telegram

5.3. FLUJO DE PENDING SELLS
---------------------------
1. main.py llama process_pending_sells() una vez por ciclo
2. Para cada pending:
   a. Valida m√≠nimo nocional
   b. Intenta colocar orden
   c. Si falla: diagnostica (locked, settlement, balance)
   d. Decide: reintentar, ajustar tama√±o, o abandonar
3. Actualiza _pending_sells con los que siguen pendientes

================================================================================
6. CONCLUSIONES
================================================================================

6.1. ESTADO ACTUAL DEL C√ìDIGO
-----------------------------
‚úÖ CORRECTO: La l√≥gica central est√° bien implementada
‚úÖ CORRECTO: Todos los casos l√≠mite conocidos tienen manejo
‚úÖ CORRECTO: El bug cr√≠tico de sell_size ha sido corregido
‚úÖ CORRECTO: Notificaciones de Telegram con retry
‚úÖ CORRECTO: M√≠nimo din√°mico basado en valor nocional

6.2. PUNTOS DE ATENCI√ìN
-----------------------
‚ö†Ô∏è Hay una l√≠nea duplicada en _process_buy_fill (l√≠neas 780-781):
   logger.warning(f"‚ö†Ô∏è Balance check failed, using accumulator size: {e}")
   logger.warning(f"‚ö†Ô∏è Balance check failed, using accumulator: {e}")

6.3. RECOMENDACIONES
--------------------
1. Agregar tests unitarios para los casos l√≠mite
2. Considerar a√±adir m√©tricas de Prometheus/Grafana
3. Implementar circuit breaker si la API falla repetidamente
4. Agregar health check endpoint para monitoreo

================================================================================
7. AN√ÅLISIS DE FALLOS REPORTADOS POR AUDITOR EXTERNO
================================================================================

A continuaci√≥n se analiza cada fallo reportado, determinando su VERACIDAD
y el IMPACTO REAL en la estrategia.

-------------------------------------------------------------------------------
FALLO 1: ‚ò†Ô∏è LA TRAMPA DEL STOP-LOSS
-------------------------------------------------------------------------------
ALEGACI√ìN:
Si cancel_order() falla por timeout (servidor cancela pero bot recibe error),
el bot entra en bucle infinito intentando cancelar una orden fantasma.

C√ìDIGO RELEVANTE (l√≠neas 525-533):
    try:
        self.client.cancel_order(order.order_id)
        self._known_filled.add(order.order_id)  # Mark as handled
    except Exception as e:
        logger.error(f"‚ùå Failed to cancel TP for SL: {e}")
        continue

VEREDICTO: ‚úÖ VERDADERO - FALLO REAL

AN√ÅLISIS:
El auditor tiene RAZ√ìN. Si la cancelaci√≥n tiene √©xito en el servidor pero
el bot recibe un error de red:

1. El bot hace `continue` y NO marca la orden como procesada
2. En el siguiente ciclo, `order.order_id` NO est√° en `_known_filled`
3. El bot intenta cancelar de nuevo ‚Üí API dice "orden no existe" ‚Üí Exception
4. Bucle infinito mientras el precio cae

IMPACTO: CR√çTICO - P√©rdida potencial total de la posici√≥n

SOLUCI√ìN PROPUESTA:
    try:
        self.client.cancel_order(order.order_id)
    except Exception as e:
        logger.error(f"‚ùå Failed to cancel TP for SL: {e}")
        # NUEVO: Verificar si la orden realmente existe
        try:
            order_status = self.client.get_order(order.order_id)
            if order_status is None or order_status.get("status") in ["CANCELLED", "CANCELED"]:
                logger.warning("üìã Orden ya cancelada (timeout anterior). Procediendo...")
                # Continuar con la venta de p√°nico
            else:
                continue  # Realmente fall√≥, reintentar
        except:
            continue
    
    self._known_filled.add(order.order_id)
    # ... ejecutar venta de p√°nico ...

-------------------------------------------------------------------------------
FALLO 2: üß† AMNESIA POST-REINICIO (P√©rdida de Dust)
-------------------------------------------------------------------------------
ALEGACI√ìN:
El _fill_accumulator vive solo en RAM. Si el bot se reinicia, pierde la
memoria de shares parciales acumuladas, dej√°ndolas hu√©rfanas.

C√ìDIGO RELEVANTE (l√≠nea 50):
    self._fill_accumulator: Dict[tuple, Dict] = {}  # Solo en RAM

VEREDICTO: ‚úÖ VERDADERO - FALLO REAL (pero impacto BAJO)

AN√ÅLISIS:
El auditor tiene RAZ√ìN t√©cnicamente. El acumulador NO se persiste.

ESCENARIO:
1. Bot compra 0.5 shares (acumulando para llegar a ~2.1 shares = $1)
2. Bot crashea
3. Al reiniciar, _fill_accumulator = {} (vac√≠o)
4. Las 0.5 shares est√°n en la wallet pero el bot no las "conoce"

SIN EMBARGO, hay mitigaciones:

MITIGACI√ìN 1: El acumulador se vac√≠a r√°pido
- Si ORDER_SIZE = 50 shares y el precio es 48¬¢
- El m√≠nimo requerido es ~2.1 shares ($1 / 0.48)
- Un solo fill de 50 shares >> 2.1, as√≠ que se vende inmediatamente
- El acumulador solo tiene datos "pendientes" por fracciones de segundo

MITIGACI√ìN 2: Al pasar a LIVE, _flush_accumulator_for_event() procesa todo
- Si hay dust y el evento pasa a LIVE, se intenta vender
- El peor caso es perder el dust (< $1 por definici√≥n)

IMPACTO: BAJO - M√°xima p√©rdida = $0.99 por posici√≥n en el peor caso

SOLUCI√ìN PROPUESTA (opcional):
Persistir _fill_accumulator en archivo JSON o Redis, aunque el ROI
de implementarlo es cuestionable dado el bajo impacto.

-------------------------------------------------------------------------------
FALLO 3: üé∞ EL "INVERSOR ACCIDENTAL" (Race Condition en Transici√≥n)
-------------------------------------------------------------------------------
ALEGACI√ìN:
Si una venta se ejecuta justo antes de LIVE, el bot recarga (compra) porque
su estado a√∫n es ACCUMULATING. La compra puede llenar antes de que
transition_to_live() cancele, dejando una posici√≥n no deseada.

C√ìDIGO RELEVANTE (l√≠neas 940-954):
    if self._states.get(slug) == StrategyState.ACCUMULATING and not is_stop_loss:
        reload_order = self.client.place_limit_order(
            price=entry_price,  # Ej: 48¬¢
            ...
        )

VEREDICTO: ‚ö†Ô∏è PARCIALMENTE VERDADERO - Riesgo BAJO

AN√ÅLISIS:
El auditor tiene raz√≥n en la MEC√ÅNICA, pero ignora factores mitigantes:

MITIGACI√ìN 1: Los reloads son √≥rdenes L√çMITE, no de mercado
- Se colocan a 40-48¬¢ (precios de la escalera)
- Para que se llenen instant√°neamente, el mercado tendr√≠a que caer a esos precios
- Si el mercado est√° subiendo hacia LIVE, estas √≥rdenes NO se llenan

MITIGACI√ìN 2: audit_cancelled_orders() detecta fills de √∫ltima hora
- Incluso si la orden se llena durante la cancelaci√≥n, se detecta
- Se coloca la venta correspondiente

MITIGACI√ìN 3: La ventana de tiempo es m√≠nima
- El ciclo del bot es ~0.5 segundos
- La probabilidad de que TODO esto ocurra en ese instante es muy baja

ESCENARIO DE RIESGO REAL:
1. Take-profit @ 49¬¢ se ejecuta (el mercado est√° alto)
2. Bot coloca reload buy @ 48¬¢
3. Flash crash instant√°neo llena el buy @ 48¬¢
4. Evento pasa a LIVE
5. Bot cancela buys pero la orden ya llen√≥
6. audit_cancelled_orders() detecta el fill y coloca sell

IMPACTO: BAJO - El sistema YA tiene manejo de este caso con audit_cancelled_orders()

SOLUCI√ìN ADICIONAL (defensiva):
    # Antes de recargar, verificar si el evento est√° por pasar a LIVE
    if self._states.get(slug) == StrategyState.ACCUMULATING and not is_stop_loss:
        # NUEVO: Verificar tiempo restante del evento
        if event.time_to_live is not None and event.time_to_live < 60:  # < 1 min
            logger.warning("‚è∞ Evento pr√≥ximo a LIVE, omitiendo reload")
            return
        
        reload_order = self.client.place_limit_order(...)

-------------------------------------------------------------------------------
FALLO 4: üëª FILLS "FANTASMA" (Dependencia de API)
-------------------------------------------------------------------------------
ALEGACI√ìN:
Si la API devuelve None repetidamente para una orden que s√≠ se llen√≥,
el bot nunca se entera y no coloca la venta.

C√ìDIGO RELEVANTE (l√≠neas 239-241):
    order_data = self.client.get_order(order.order_id)
    
    if not order_data:
        continue

VEREDICTO: ‚ö†Ô∏è PARCIALMENTE VERDADERO - Riesgo MEDIO

AN√ÅLISIS:
El auditor tiene raz√≥n en que un `continue` silencioso es peligroso.

SIN EMBARGO, hay mitigaciones:

MITIGACI√ìN 1: La detecci√≥n principal NO usa get_order()
- check_fills() PRIMERO verifica si `order.order_id not in open_order_ids`
- open_order_ids viene de get_open_orders() (lista de todas las √≥rdenes)
- Si una orden desaparece de la lista, SABEMOS que algo pas√≥

MITIGACI√ìN 2: Las √≥rdenes de alta prioridad (‚â•46¬¢) se verifican siempre
- Aunque la orden siga "abierta", se llama get_order() cada ciclo
- Solo las de baja prioridad (<46¬¢) que siguen abiertas se saltan

MITIGACI√ìN 3: El balance real est√° en la blockchain
- Si compramos tokens, EST√ÅN en nuestra wallet
- Aunque el bot no lo sepa, no se "pierden"

ESCENARIO DE RIESGO REAL:
1. Orden @ 44¬¢ se llena parcialmente (10 de 50 shares)
2. API get_order() devuelve None por lag
3. La orden sigue en open_order_ids (no desapareci√≥)
4. Bot no detecta el partial fill
5. Tokens comprados pero sin venta colocada

IMPACTO: MEDIO - Posible posici√≥n hu√©rfana que requiere intervenci√≥n manual

SOLUCI√ìN PROPUESTA:
    order_data = self.client.get_order(order.order_id)
    
    if not order_data:
        # NUEVO: Contar intentos fallidos
        if not hasattr(order, 'api_fail_count'):
            order.api_fail_count = 0
        order.api_fail_count += 1
        
        if order.api_fail_count >= 10:
            logger.error(f"‚ö†Ô∏è API failing for order {order.order_id[:10]} x{order.api_fail_count}")
            self.notifier.send_message(f"‚ö†Ô∏è ALERTA: API no responde para orden. Verificar manualmente.")
        continue

-------------------------------------------------------------------------------
FALLO 5: üíß RIESGO DE LIQUIDEZ EN MARKET SELL
-------------------------------------------------------------------------------
ALEGACI√ìN:
La orden de stop-loss a 1¬¢ puede ejecutarse a precios rid√≠culos si no hay
compradores en el libro de √≥rdenes.

C√ìDIGO RELEVANTE (l√≠neas 537-540):
    dump_order = self.client.place_limit_order(
        price=0.01,  # Market sell (crosses any bid)
        size=order.size,
        ...
    )

VEREDICTO: ‚úÖ VERDADERO - Pero es ACEPTABLE por dise√±o

AN√ÅLISIS:
El auditor tiene RAZ√ìN t√©cnicamente. En un flash crash extremo con libro
de √≥rdenes vac√≠o, la ejecuci√≥n ser√≠a catastr√≥fica.

SIN EMBARGO, esto es un TRADEOFF CONSCIENTE:

ARGUMENTO 1: El objetivo del stop-loss es SALIR, no obtener buen precio
- Si el precio cay√≥ de 48¬¢ a 18¬¢, ya perdimos 62.5%
- Vender a 15¬¢ vs 10¬¢ vs 5¬¢ es irrelevante comparado con perder 100%

ARGUMENTO 2: En mercados de predicci√≥n, 0 o 100 son los √∫nicos finales
- Si NO vendemos y el mercado resuelve en contra, perdemos TODO
- Vender a 5¬¢ es infinitamente mejor que recibir $0 al resolver

ARGUMENTO 3: Los mercados de Polymarket tienen liquidez razonable
- No son shitcoins de DEX con 3 holders
- Mercados de eventos pol√≠ticos tienen millones en volumen

IMPACTO: ACEPTABLE - El slippage extremo es preferible a p√©rdida total

SOLUCI√ìN ALTERNATIVA (si se desea):
Usar precio m√≠nimo m√°s alto (ej: 5¬¢ en lugar de 1¬¢) para limitar slippage,
aceptando el riesgo de que la orden no se llene si no hay bids.

-------------------------------------------------------------------------------
FALLO 6: üîí BLOQUEO POR INTERVENCI√ìN HUMANA
-------------------------------------------------------------------------------
ALEGACI√ìN:
Si el usuario coloca manualmente una orden de venta, bloquea los tokens
y el bot no puede operar, entrando en loop de errores.

C√ìDIGO RELEVANTE (c√°lculo de locked_in_sells):
    locked_in_sells = sum(
        float(o.get("size", 0)) - float(o.get("size_matched", 0))
        for o in open_orders
        if o.get("asset_id") == token_id and o.get("side") == "SELL"
    )
    available_balance = actual_balance - locked_in_sells

VEREDICTO: ‚úÖ VERDADERO - Pero es COMPORTAMIENTO CORRECTO

AN√ÅLISIS:
El auditor describe correctamente el comportamiento, pero lo interpreta
como un "fallo" cuando en realidad es PROTECCI√ìN.

ARGUMENTO 1: El bot DEBER√çA detenerse si hay intervenci√≥n manual
- Si el humano coloc√≥ una orden, tiene una raz√≥n
- El bot no debe competir con el humano por los mismos tokens

ARGUMENTO 2: El logging no es "llenar de errores"
- El bot detecta la situaci√≥n y la reporta claramente
- "üîí Tokens locked: X total, Y in open sells"
- Esto es INFORMATIVO, no un error

ARGUMENTO 3: El bot se adapta
- Si quedan tokens disponibles, los usa
- Si no, espera a que la orden manual se resuelva

IMPACTO: NO ES UN FALLO - Es comportamiento defensivo correcto

RECOMENDACI√ìN: Agregar detecci√≥n expl√≠cita de √≥rdenes "no conocidas"
    # Detectar si hay √≥rdenes que el bot no coloc√≥
    unknown_sells = [
        o for o in open_orders
        if o.get("asset_id") == token_id
        and o.get("side") == "SELL"
        and o.get("id") not in [s.order_id for s in self._sell_orders.get(slug, [])]
    ]
    if unknown_sells:
        logger.warning(f"‚ö†Ô∏è Detected {len(unknown_sells)} manual sell orders!")
        self.notifier.send_message("‚ö†Ô∏è √ìrdenes manuales detectadas. Bot pausado.")

===============================================================================
RESUMEN DE FALLOS
===============================================================================

| # | Fallo                          | Veredicto        | Impacto   | Acci√≥n    |
|---|--------------------------------|------------------|-----------|-----------|
| 1 | Trampa del Stop-Loss           | ‚úÖ VERDADERO     | CR√çTICO   | CORREGIR  |
| 2 | Amnesia Post-Reinicio          | ‚úÖ VERDADERO     | BAJO      | ACEPTAR   |
| 3 | Inversor Accidental            | ‚ö†Ô∏è PARCIAL       | BAJO      | MITIGADO  |
| 4 | Fills Fantasma                 | ‚ö†Ô∏è PARCIAL       | MEDIO     | MEJORAR   |
| 5 | Riesgo de Liquidez             | ‚úÖ VERDADERO     | ACEPTABLE | POR DISE√ëO|
| 6 | Bloqueo por Intervenci√≥n       | ‚ùå NO ES FALLO   | N/A       | CORRECTO  |

CONCLUSI√ìN:
Solo el FALLO 1 (Trampa del Stop-Loss) requiere correcci√≥n URGENTE.
Los dem√°s son riesgos aceptables, mitigados, o comportamiento correcto.

================================================================================
                         FIN DEL INFORME DE AUDITOR√çA
================================================================================
